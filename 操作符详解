#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <math.h>

/*
分类：算数操作符  移位操作符 位操作符 赋值操作符 单目操作符 关系操作符 逻辑操作符 条件操作符 逗号表达式 下标引用，函数调用和结构成员

*/


//移位操作符
//右移
//int main()
//{
//	int a = -1;
//	//>>右移操作符   移动的是二进制位
//	//1.算术右移
//	//     右边丢弃，左边补原符号位
//	//2.逻辑右移
//	//     右边丢弃，左边补0
//
//	//正数的二进制表示有：原码 反码 补码
//	//存储到二进制的补码
//	//正数的补码就是它自己
//	//负数的补码      拿-1来说 原码 100000000000000000000000000000001 反码 111111111111111111111111111111110 补码就是反码加一 111111111111111111111111111111111
//	a = a >> 1;
//	printf("%d", a);
//	return 0;
//}


//位操作符  &按位与  |按位或 ^按位异或
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a & b;
//	int d = a | b;
//	int e = a ^ b;
//	printf("%d", c);
//	printf("%d", d);
//	printf("%d", e);
//	return 0;
//}

//练习，求一个整数存储在内存中的二进制中的1的个数
//int main()
//{
//	int num = 0;
//	int count = 0;
//	scanf("%d", &num);
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if (1 == ((num >> i) & 1))
//		{
//			count++;
//		}
//	}
//	printf("%d\n", count);
//	return 0;
//}

//单目操作符： !:逻辑反操作  -:负值  +:正值  &:取地址  sizeof:操作数的类型长度  ~:对一个数的二进制按位取反  --:前后置--  ++:前后置++  *:解引用操作符  (类型)：强制类型转换
//int main()
//{
//	int a = 10;
//	//printf("%d\n", ++a);//前置++，先++，后使用
//	printf("%d\n", a++);//后置++，先使用，在++
//	printf("%d\n", a);
//	return 0;
//}

//练习
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++;//先是a++，因为是后置++所以先使用，这里a=0，按照逻辑与的运算后面的++b d++ 都没有执行，所以最后打印的结果是1234
//	i = a++ || ++b || d++;
//	printf("a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);
//	return 0;
//}

//逗号表达式：就是用逗号隔开的多个表达式，从左向右依次执行，整个表达式的结果是最后一个表达式的结果
//int main()
//{
//	int a = 1;
//	int b = 2;
//	//int c = (a > b, a = a + b, a, b = a + 1); //即b=a+1的值就是c的值
//	//if (a = b + 1, c = a / 2, d > 0);
//
//	return 0;
//}

//下标引用，函数调用和结构成员
/*
 1.[]下标引用操作符
    操作数：一个数组名+一个索引值
 2.()函数调用操作符，接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数
*/




//结构成员
//创建了一个结构体类型 struct Stu
//struct Stu
//{
//	//成员变量
//	char name[20];
//	int age;
//	char  id[20];
//};
//int main()
//{
//	int a = 10;
//	//使用struct Stu这个类型创建了一个学生对象s1，并对他初始化
//	struct Stu s1 = { "张三",20,"20195258" };
//	struct Stu* ps = &s1;
//	printf("%s\n", (*ps).name);
//	printf("%d\n", (*ps).age);
//	printf("%s\n", (*ps).id);
//	printf("%s\n", ps->name);
//	printf("%d\n", ps->age);
//	printf("%s\n", ps->id);
//	/*printf("%s\n", s1.name);
//	printf("%d\n", s1.age);
//	printf("%s\n", s1.id);*/
//	//结构体变量.成员变量
//	return 0;
//}



//隐式类型转换
/*                    c的整型算数运算总是以缺省整型类型的精度来进行的
                     为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升
例如： char a,b,c;
       a=b+c;         b和c的值被提升为普通整型，然后在执行加法运算，加法运算完成之后，结果将被截断，然后在储存在a中
         如何进行整体提升呢？：整体提升是按照变量的数据类型的符号位来提升的

                 整型提升的意义：通用cpu是难以直接实现两个8比特字节直接相加运算，所以表达式中各种长度可能小于int的整型值，都必须转换为int或unsigned int ，然后才能送入cpu执行运算
                     */
//int main()
//{
//    char a = 3;//整型3的值为：000000000000000000000000000000011
//               //字符a的值为00000011
//    char b = 127;//整型127的值为：00000000000000000000000001111111
//                 //字符b的值为01111111
//    char c = a + b;//a和b如何相加？
//                   //a和b的整型提升是按最高位的符号位来提升的，就拿字符a来说，它的最高位是0，所以提升为int时前面全部补0
//                   //a=00000000000000000000000000000011
//                   //b=00000000000000000000000001111111
//                   //  00000000000000000000000010000010=a+b
//                   //此时c被截断为10000010
//    printf("%d\n", c);//打印时是按照整型打印的，所以c要进行整型提升，提升为11111111111111111111111110000010------这时储存在计算机里的是补码，因为符号位是1
//                      //                                                   11111111111111111111111110000001------反码
//                      //                                                   00000000000000000000000001111110------补码，所以结果为-126
//	return 0;
//}
