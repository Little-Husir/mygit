#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <math.h>
 
/*
     数据的存储：
	 深度剖析数据在内存中的存储
	 本章重点：
	          *数据类型详细介绍
			  *整型在内存中的存储：源码，反码，补码
			  *大小端字节序介绍及判断
			  *浮点型在内存中的存储解析
	c语言类型分为两大类
	          1内置类型：char short int long longlong float double
			  2自定义类型（构造类型）
			  类型的意义：1.使用这个类型开辟空间的大小（大小决定了使用范围)
			              2.如何看待内存空间的视角


	          整型家族：char short int long 
			            unsigned 和 signed 无符号数和有符号数的区别：有符号数，即一个数的最高位为符号位，无符号数即最高位不视为符号位
			  浮点型家族：float 单精度浮点型 double 双精度浮点型
			  构造类型：
			           数组类型
					   结构体类型：struct
					   枚举类型：enum
					   联合类型：union
			  指针类型：int* p;char* p;float* p;void* p
			  空类型：void表示空类型 通常用于函数的返回类型，函数的参数，指针类型
    整型在类存中在存储：
	          计算机中的有符号数有三种表示方法，即源码，反码，补码
			           三种表示方法均有符号位和数值位两部分，符号位都是用0表示正，1表示负，数值位三种表示方法各不相同
					   无符号数和正数一样原码 ，反码， 补码相同
					   原码：直接将二进制按照正负数的形式翻译成二进制就可以
					   反码：原码的符号位不变，其他位依次按位取反就可以得到
					   补码：反码加1得到补码
   
   大小端字节序介绍及判断:
             大端（存储）模式：是指数据的低位保存在内存的高地址中，而数据的高位，保存内存的低地址中；
			 小端（存储）模式：是指数据的低位保存在内存的低地址中，而数据的高位，保存内存的高地址中；
			                                0x11223344
			 | | | | | | | | |11|22|33|44| | | | | | |44|33|22|11| | | | | | | | | | | | | | | | | |
			 低地址           大端模式存储            小端模式存储                            高地址
   浮点型在内存中的储存：


*/

//原码，反码，补码的介绍
//int main()
//{
//	int a = 20;
//	//通过查看内存发现vs下的数据存储是小端模式
//	//000000000000000000000000 00010100---原码
//	//000000000000000000000000 00010100---反码
//	//000000000000000000000000 00010100---补码
//	//0x00000014---计算机里存储是以16进制展示的
//	int b = -10;
//	//100000000000000000000000 00001010---原码
//	//111111111111111111111111 11110101---反码
//	//111111111111111111111111 11110110---补码
//	//0xfffffff6
//	return 0;
//}


//设计一个小程序来判断当前机器的字节序
//int main()//方法1
//{
//	int a = 1;
//	char* p = (char*)&a;//强制类型转换为char* 这里p和a的地址是相同的，但p++的时候是一个字节一个字节的跳，而int* p是4个字节跳
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}


//方法2
//int check_sys()
//{
//	int a = 1;
//	char* p = (char*)&a; //return *(char*)&a
//	return *p;
//}
//int main()
//{
//	int ret = check_sys();//返回1，小端    返回0，大端
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}


//int main()
//{
//	int a = 123;//在内存中存放的是16进制数，转换为16进制就是7b
//	int a = 0x11223344;//因为0x11223344本身就是16进制数，所以在内存中存放的就是11223344
//	int* p = &a;
//	*p = 0;
//	return 0;
//}


//练习
//下列代码输出什么？
//int main()
//{
//	char a = -1;
//	//1000000000000000000000000000001-原码
//	//1111111111111111111111111111110-反码
//	//1111111111111111111111111111111-补码
//	//所以a和b都是11111111
//	signed char b = -1;
//	unsigned char c = -1;//进行整型提升    c也是11111111
//	printf("a=%d,b=%d,c=%d\n", a, b, c);//打印的时候是整型，所以打印原码就是-1，a和b一样，但c是无符号字符型
//	              //无符号数整型提升高位补0，所以c的补码为00000000000000000000000011111111，由于最高位是0，是正数，所以
//	              //原码，反码，补码相同，打印结果为255，
//	              //结论：数据存储在内存中是以补码的形式储存的，打印的时候是打印的补码
//	return 0;
//}


//int main()
//{
//	char a = -128;
//	//1000000000000000000000010000000-原码
//	//1111111111111111111111101111111-反码
//	//1111111111111111111111110000000-补码
//	//1111111111111111111111110000000-整型提升结果，
//	printf("%u\n", a);//%u打印无符号整数，即表示该数原码，补码，反码相同，所以打印的是整型提升的结果  转换为十进制就是是4294967168
//	                  //打印的是按整型打印的，所以要整型提升
//	return 0;
//}


//int main()
//{
//	char a = 128;
//	printf("%u\n", a);//和上面的打印结果一样，因为char类型放不下128，拆分成127+1，那么a就变成了-128，所以两者打印结果一样
//	return 0;
//}


//int main()
//{
//	int i = -20;
//	//100000000000000000000000 00010100--原码
//	//111111111111111111111111 11101011--反码
//	//111111111111111111111111 11101100--补码
//	unsigned int j = 10;
//	//000000000000000000000000 00001010
//	//111111111111111111111111 11110110//i+j的补码
//	//111111111111111111111111 11110101//i+j的反码
//	//100000000000000000000000 00001010//i+j的原码   即打印的值
//	printf("%d\n", i + j);
//	return 0;
//}


//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		
//		printf("%u\n", i);//987654321到死循环
//		Sleep(100);
//	}
//	return 0;
//}


//int main()
//{
//	char a[1000];//一个char的范围时-128~127之间
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//		//100000000000000000000000 00000001-原码
//		//111111111111111111111111 11111110-反码
//		//111111111111111111111111 11111111-补码
//		//000000000000000000000000 00000001
//		//111111111111111111111111 11111110     -1-1的补码
//		//111111111111111111111111 11111101     -1-1的反码
//		                                
//		//100000000000000000000000 00000010     -1-1的原码 即a[1]=-2;a[2]=-3;
//	}
//	printf("%d", strlen(a));//strlen函数计算到0时就不再计算字符串长度，所以-1.....-128 127 .....0之间有255个，所以打印的结果是255
//	return 0;
//}

//unsigned char i = 0;//i存放分范围时0~255所以会一直循环下去
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}


int main()
{
	int n = 9;
	float* pfloat = (float*)&n;
	printf("n的值为：%d\n", n);//9
	printf("pfloat的值为：%f\n", pfloat);//0.000000

	*pfloat = 9.0;
	printf("num的值为：%d\n", n);//1091567616
	printf("*pfloat的值为：%f\n", *pfloat);//9.000000
	return 0;
}


