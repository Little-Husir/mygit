#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <math.h>

/*
  本章重点：1.指针是什么           2.指针和指针类型          3.野指针           4.指针运算
            5.指针和数组           6.二级指针                7.指针数组
            1.指针是什么？ 在计算机科学中，指针是编程语言中的一个对象，利用地址，它的值直接指向存在电脑存储器中另一个地方的值，由于通过地址能找到所需的变量
         单元，可以说，地址指向该变量单元，因此将地址形象化的称为指针，意思是通过它找到以他为地址的内存单元。
            总结：指针就是变量，用来存放地址的变量（存放在指针中的值都被当成地址来处理）
                      *一个小的单元是一个字节  8个比特位
                      *在32位机器上，一个指针变量的大小为4个字节
                      *在64位机器上，一个指针变量的大小为8个字节
                      *如何编址？如果是32位地址线，那么他的地址就是32个全0到32个全1 空间大小为2^32byte大小即为4GB
            2.指针和指针类型
                   指针的空间大小都是4，那为什么还区分指针类型呢？  
                        因为指针类型决定了指针进行解引用操作的时候，能够访问空间的大小
                         int* p; *p能够访问4个字节
                         char* p；*p能够访问1个字节
                         double* p；*p能够访问8个字节
                   指针+-整数
                        指针类型决定了：指针走一步走多远（指针的步长,单位是字节）
                             int* p; p+1-->4
                             char* p；p+1-->1
                             double* p；p+1-->8
            3.野指针
                概念：野指针就是指针指向的位置是不可知的（随机的，不正确的，没有明确限制的）
                野指针成因：
                    *指针未初始化
                    *指针越界访问
                    *指针指向的空间释放
                如何规避野指针？
                    *1.指针初始化
                    *2.小心指针越界
                    *3.指针指向空间释放及时置null
                    *4.指针使用之前检查有效性
            4.指针运算
                *指针+-整数
                *指针-指针
                *指针的关系运算   两个指针比较时有一个标准规定：允许指向元素数组的指针与最后一个元素后面的那个内存位置的指针比较
                                                                 但是不允许与指向第一个元素之前的那个内存位置的指针进行比较
            5.指针和数组
            6.二级指针
            7.指针数组
*/

//1.指针是什么？
//int main()
//{
//    int a = 10;//在内存中开辟一块空间
//    int* p = &a;//指针变量    这里我们对变量a，取出它的地址，可以使用&操作符
//                //将a的地址存放到p变量中，p就是一个指针变量
//	return 0;
//}

//2.指针和指针类型
//int main()
//{
//   /* printf("%d\n", sizeof(char*));
//    printf("%d\n", sizeof(short*));
//    printf("%d\n", sizeof(int*));
//    printf("%d\n", sizeof(double*));*/
//    int a = 0x11223344;
//    int* pa = &a;
//    //*pa = 0;//通过地址改值
//    char* pc = &a;
//    *pc = 0;//字符型指针变量去改整型指针变量的值修改不全，只会修改字符所占空间的那部分，即11223344，只会把44改为00，从低地址开始改，
//                //即指针变量类型决定了你能操作的地址空间
//    printf("%p\n", pa);
//    printf("%p\n", pc);
//	return 0;
//}


//int main()
//{
//    int a = 0x11223344;
//    int* pa = &a;
//    char* pc = &a;
//    printf("%p\n", pa);//0034fe08
//    printf("%p\n", pa+1);//0034fe0c
//    printf("%p\n", pc);//0034fe08
//    printf("%p\n", pc+1);//0034fe09  通过对比可知，指针类型决定了：指针走一步走多远（指针的步长）
//	return 0;
//}

//指针类型的价值,,数组的解引用访问，
//int main()
//{
//    int arr[10] = { 0 };
//    //int* p = arr;//数组名，首元素的地址 可以将arr中的值依次访问并赋值为1 40个字节全部访问到
//    char* p = arr;//不能依次赋值，只访问到了10个字节，
//    int i = 0;
//    for (i = 0; i < 10; i++)
//    {
//        *(p + i) = 1;
//    }
//	return 0;
//}


//野指针
//*指针未初始化
//int main()
//{
//    int a;//局部变量不初始化，默认是随机值
//    int* p;//局部的指针变量，就被初始化随机值
//    *p = 20;
//	return 0;
//}

//*指针越界访问
//int main()
//{
//    int arr[10] = { 0 };
//    int* p = arr;
//    int i = 0;
//    for (i = 0; i < 12; i++)
//    {
//        p++;
//    }
//    //当指针指向的范围超出数组arr的范围时，p就是野指针
//	return 0;
//}

//指针指向的空间释放
//int* test()
//{
//    int a = 10;
//    return &a;
//}
//int main()
//{
//    int* p = test();
//    *p = 20;//因为函数只是在调用时有用，所以*p在使用之前，a的空间就被回收释放掉了，
//	return 0;
//}


//int main()
//{
//    int* p = NULL;//指针初始化不知道怎样赋值时就赋值为NULL
//	return 0;
//}


//指针+-整数
//int main()
//{
//    int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//    int i = 0;
//    int sz = sizeof(arr) / sizeof(arr[0]);
//    //int* p = arr;
//    int* p = &arr[9];//p可以指向数组的任意一个元素
//    //for (i = 0; i < sz; i++)
//    //{
//    //    printf("%d \n", *p);
//    //    p = p + 1;//等价p++
//    //}
//    for (i = 0; i < 5; i++)
//    {
//        printf("%d \n", *p);
//        //p = p + 2;
//        p = p - 2;
//    }
//	return 0;
//}


//指针  -  指针  注意的是这两个指针应指向同一块空间
//int main()
//{
//    int ch[5] = { 0 };
//    int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//    printf("%d\n",&arr[9] - &arr[0]);//指针-指针得到的是两个指针之间元素的个数，这里打印出来的结果是9
//    printf("%d\n", &arr[9] - &ch[0]);//错误的写法
//	return 0;
//}


//strlen--求字符串长度
//前面用递归的方式模拟实现了strlen-     方式1.计数器的方式      方式2.递归的方式  方式3.指针的方式，如下代码

//int my_strlen(char* str)
//{
//    char* start = str;
//    char* end = str;
//    while (*end != '\0')
//    {
//        end++;
//    }
//    return end - start;
//}
//int main()
//{
//    char arr[] = "bit";
//    int len = my_strlen(arr);
//    printf("%d\n", len);
//	return 0;
//}


//指针的关系运算--即比较大小
//int main()
//{
//    float values[5];
//    float* vp;
//    for (vp = &values[4]; vp >= &values[0]; vp++)
//    {
//        *vp = 0;
//    }
//	return 0;//避免这样写   
//}


//指针和数组
//int main()
//{
//    int arr[10] = { 0 };
//    printf("%p\n", arr);//地址--首元素的地址   但是有两个例外 1.&arr-&数组名-这个时候数组名不是首元素的地址而是表示整个数组的地址，
//                                                          //列如&arr+1,打印出来的结果是原数组加上一个原数组arr(大小为40)的地址
//                                                          //  2.sizeof（arr）--此时是计算整个数组的大小，单位是字节
//    printf("%p\n", arr[0]);
//	return 0;
//}


//数组可以通过指针来访问
//int main()
//{
//    int arr[10] = { 0 };
//    int* p = arr;
//    int i = 0;
//    for (i = 0; i < 10; i++)
//    {
//        *(p + i) = 1;
//    }
//    for (i = 0; i < 10; i++)
//    {
//        printf("%d === %d\n",*(p+i), arr[i]);
//    }
// /*   for (i = 0; i < 10; i++)
//    {
//        printf("%p   ======   %p\n",p+i, &arr[i]);
//    }*/
//	return 0;
//}


//二级指针
//int main()
//{
//    int a = 10;
//    int* pa = &a;
//    int** ppa = &pa;//ppa就是一个二级指针
//    int*** pppa = &ppa;//pppa就是一个三级指针，以此类推可以有5-6级指针
//    printf("%d\n", **ppa);//值为10
//	return 0;
//}


//指针数组：本质是数组----是存放指针的数组
//数组指针：本质是指针
int main()
{
    int a = 10;
    int b = 20;
    int c = 30;
    //int* pa = &a;
    //int* pb = &b;
    //int* pc = &c;
    ////整型数组-存放整型
    ////字符数组-存放字符
    ////指针数组-存放指针
    //int arr[10];
    int* arr2[3] = { &a,&b,&c };//指针数组
    int i = 0;
    for (i = 0; i < 3; i++)
    {
        printf("%d\n",*(arr2[i]));
    }
	return 0;
}
